# ProjetoSP470-Doc
Documentação e scripts do jogo

<h2>Áudio</h2>
<ul>
  <li><h4>Música</h4></li>
  <ul>
  <li><p>Sampa Midnight foi a música que nos inspiramos para fazer o jogo e também como música de fundo. A música fala sobre o cantor e mais dois amigos, eles sendo Bartolomeu e Ptolomeu, eles estavam bêbados e passeando pela Paulista quando de repente um breu tomou todo o lugar e surgiram três criaturas brilhantes gritando "não somos gente" com chifres e tridentes, com base nisso, nós fizemos um caminho da Paulista até a Catedral da Sé pois a catedral simboliza todo o início de São Paulo. </p></li>
  </ul>
  <li><h4>Efeitos Sonoros</h4></li>
</ul>

<h2>História:</h2>
<p>Começamos pensando em como juntar os passado e presente da cidade em um único ambiente, e logo, pensamos nos fantasmas. Então pesquisamos pontos marcantes da cidade que eram séculos atrás, e outros que são importantes atualmente; chegando na Catedral da Sé e na Avenida Paulista. Com os NPCs e cenário definidos, procuramos pelo nosso protagonista na Asset Store do Unity e encontramos um personagem que possuia uma expressão séria e determinada que encaixava no conceito do jogo.</p>

<p>Aruã, um xamã caçador de fantasmas conhecido por suas habilidades únicas, foi chamado às pressas pelos diretores da Catedral da Sé. O local, um dos mais icônicos de São Paulo, havia se tornado palco de estranhos eventos sobrenaturais, e somente alguém com a expertise de Aruã poderia resolver a situação.</p>
<p>Ele estava em direção à Catedral, até que seu carro quebra na Avenida Paulista. No entanto, ao chegar na Avenida Paulista, percebeu que havia cometido um erro grave: ele havia esquecido seus talismãs, aqueles que normalmente usava para capturar e repelir espíritos malignos. A Avenida Paulista, que já era conhecida por sua energia vibrante, agora parecia estar imersa em uma aura pesada, quase sufocante. Espíritos malignos flutuavam pela rua, Aruã, agora mais cauteloso, começou a desviar deles, percebendo que sem seus talismãs, qualquer confronto direto poderia ser fatal.</p>
  <p>Ao se aproximar da catedral, outro desafio surge, um labirinto com mais fantasmas. Dentro desse labirinto, surge o espírito de Tarsila do Amaral, uma das maiores artistas que o Brasil já produziu. Diferente dos outros espíritos, Tarsila emanava uma luz suave e acolhedora. “Aruã”, ela chamou, sua voz era ao mesmo tempo distante e familiar, ela menciona uma dívida que tem com o pai de Aruã e, por isso, o ajudará. Tarsila lhe entregou uma máscara que ela mesma havia criado. Aruã aceitou o presente, agradecendo com um leve aceno de cabeça, então, ela o guia para o próximo passo da jornada, encontrar Monteiro Lobato na catedral.</p>
<p>Foi na biblioteca da Catedral que Aruã encontrou o espírito de Monteiro Lobato, o lendário escritor brasileiro, estava lá, imerso em seus pensamentos. Quando Aruã se aproximou, o espírito ergueu os olhos e disse "São Paulo, Aruã, é um enigma em si, uma cidade onde o tempo se entrelaça em espirais". Ele, como Tarsila, menciona uma dívida e o pai de Aruã e depois explica porque todos estes fantasmas apareceram. O xamã, com mais conhecimento ainda, segue sua jornada dentro da Catedral, até que finalmente encontrou uma porta mística, emanando uma energia antiga. Ele pegou a chave, o convite e, lembrando-se das palavras de Tarsila, colocou a máscara que havia recebido.</p>
<p>Seguindo seu caminho pela Catedral, Aruã entra em um lugar sobrenatural, como Monteiro Lobato mencionou e lá, encontra fantasmas ainda mais desafiadores. Ao usar a chave e o convite para passar por uma porta misteriosa, ele se encontra em um ambiente completamente diferente, cercado de fantasmas, e o jogo acaba com um final ambíguo.</p>

<br>
<h2>Personagens:</h2>
<ol>
<li><h4>Aruã:</h4></li>
Aruã é um xamã experiente, conhecido popularmente como um caçador de fantasmas. Ele tem 23 anos de idade, com uma estatura média e um físico ágil. Sua pele é branca, e ele possui cabelos ruivos, em um corte mullet.
Aruã veste roupas simples, funcionais, geralmente um casaco vermelho vinho, uma calça de couro preta e uma camisa preta, utilizando também botas de couro. Ele carrega consigo uma lanterna.
Aruã nasceu em uma família de classe média em São Paulo, Aruã sempre se sentiu deslocado na vida urbana. Aos 18 anos, durante uma viagem para o interior da Amazônia, ele se envolveu em uma situação perigosa e foi salvo por uma comunidade indígena. Lá, conheceu um xamã sábio que percebeu o potencial espiritual de Aruã. Fascinado e intrigado pelo conhecimento ancestral, ele resolveu ficar e aprender as artes xamânicas.
Após anos de aprendizado e prática, Aruã volta à cidade com um objetivo: usar o que aprendeu para ajudar as pessoas a encontrar a paz, tanto no mundo espiritual quanto no mundo físico.

![Captura de tela 2024-09-17 111410](https://github.com/user-attachments/assets/13294dd4-49eb-4c1c-b375-3f364720c3bb)
<p>A cor principal de Aruã é o vermelho, que está em forte contraste com o ambiente e até os fantasmas, já que seu laranja é bem fraco. Isso também diferencia eles por Aruã ter uma cor considerada mais "viva", pois seu vermelho é mais quente e saturado</p>

<li><h4>Fantasmas:</h4></li>

![fantasma1](https://github.com/user-attachments/assets/e29f140a-19d2-4817-95c1-d9e2d5810606)
<ul>
  <li><p>A cor da maioria dos fantasmas é alaranjada e desbotada, se aproximando levemente do vermelho de Aruã, porém ainda sendo bem distinta dele e do cenário. Depois, na última rua com inimigos, eles estão maiores e mais rápidos que nunca; assim, sua aparência muda, sendo uma cor cinza. No labirinto, que é uma área muito iluminada, os fantasmas possuem uma textura simples e de cor branca, para aparecerem melhor. Além disso, sua coloração simples reflete que os fantasmas do labirinto são bem mais fáceis de desviar comparado aos outros. Dentro da catedral, eles possuem chifres, dando uma sensação de maior desafio e finalização e, por serem maiores, compartilham a cor cinza com os fantasmas maiores.</p></li>
  <li><p>Localização: os fantasmas estão separados em "grupos" que ocupam certa área, dentro desse grupo, eles aumentam de velocidade conforme o jogador avança, e a dificuldade dos fantasmas de cada "grupo" também aumenta, exceto no labirinto, já que o foco é no labirinto em si, não nos inimigos.</p></li>
  <li><p>A dificuldade do jogo aumenta gradualmente(exceto no labirinto) isso foi feito com a incrementação da quantidade de fantasmas e sua velocidade. Em uma rua, removemos sua luz dificultando a visualização deles. Depois, aumentamos seu tamanho, o que aumenta sua hitbox, dificultando o desvio. Dentro da catedral, o ambiente apertado é o principal desafio que, junto do maior tamanho dos fantasmas, cria um obstáculo digno para ser o final do jogo.</p></li>
</ul>

<li><h4>Tarisila do Amaral e Monteiro Lobato</h4></li>
<p>Os dois têm uma cor azul, representando segurança e os diferenciando muito do laranja dos fantasmas hostis.</p>
</ol>
<br>
<h2>Mundo do Jogo</h2>
<ol>
  <li><h4>Mapa</h4></li>
  <p>O jogo se situa no centro de São Paulo, iniciando na Avenida Paulista e terminando na Catedral da Sé. Inicialmente, as ruas seriam similares ao mapa normal, porém decidimos simplificá-las, deixando um design linear repetitivo, onde o jogador apenas segue para a direita. Isso facilita o entendimento do trajeto, a criação do mapa e a repetitividade separa o jogo em seções, que foram usadar similarmente a fases, onde cada seção nova inclui um aumento de dificuldade.</p>

<h5>Conceito de mapa inicial do jogo e o produto final</h5>
<br>
  <li><h4>Cenário</h4></li>
  <p>No caminho até a catedral, o cenário é majoritariamente escuro, cinza e preto, com todas as outras cores pouco iluminadas, fazendo os fantasmas se destacarem e criando uma atmosfera mais assustadora e de solidão, que se encaixa perfeitamente com as ruas que normalmente são bem movimentadas e agora estão sem nenhuma pessoa. Alguns prédios mais coloridos oferecem variação, deixando o visual menos monótono. As únicas áreas mais claras são o início do jogo e o entorno da catedral, sendo as únicas áreas seguras, e dentro do labirinto, onde os inimigos são bem mais simples e fáceis de desviar (já que o foco é o labirinto). A principal dessas cores é o verde-claro das plantas, que é relacionada à perseverança, motivando Aruã a continuar sua jornada nos dois pontos principais: o início e perto do final e a segurança das áres onde está presente.</p>
  <p>Localizada no coração de São Paulo, a Catedral da Sé é um dos principais pontos da cidade e o marco final da jornada, onde Aruã irá finalizar sua missão. Dentro dela, o cinza é a cor predominante, mas desta vez, é uma cor bem clara. Isso diferencia ela de todas as outras regiões, já que a área não é baseada em nada real, porém ainda usa uma cor que encaixa como resto da paleta.</p>
</ol>
<br>
<h2>Cenas:</h2>
  <p>Separamos as cenas entre a cidade e o interior da catedral. A cidade inteira, se encontra em apenas uma cena, permitindo que o jogador vá o quão rápido ele queira, dando fluidez ao jogo. A transição de cena permite que a catedral seja menor por fora, o que facilitou sua criação no mapa e, sendo a área final, fornece um suspense e a separa do resto do jogo.</p>

<h2>Jogos inspirados:</h2>
<p>Ao decidir que os fantasmas seriam os principais inimigos, pensamos no jogo "Spooky's Jumpscare Mansion", onde, apesar de não haverem muitos fantasmas, a personagem principal e boa parte do cenário eram ótimos exemplos do design simplificado que buscávamos.</p>
<p>Os cenários de "Little Nightmares" e "Resident Evil" também foram considerados durante o desenvolvimento, também por serem mais simples, porém ao mesmo tempo construir uma atmosfera de terror.</p>
<h2>Scripts</h2>
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  # Script do Personagem

Este script fornece controle para o personagem principal, incluindo movimento, animação e pulo. Utiliza o componente `CharacterController` para gerenciar o movimento e o pulo, e o componente `Animator` para ajustar as animações do personagem com base nas ações do jogador.

## Funcionalidades

- Movimento do personagem com base na orientação da câmera
- Animação de andar, correr e pular
- Aplicação de gravidade e controle do pulo
- Teleporte do personagem para a posição inicial se cair fora do mapa

## Código

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Unity.VisualScripting;

public class Move : MonoBehaviour
{
    // Referência ao componente CharacterController usado para gerenciar o movimento
    CharacterController character;
    
    // Referência ao componente Animator usado para gerenciar animações
    Animator animator;
    
    // Armazena as entradas do jogador (movimento horizontal e vertical)
    Vector3 inputs;
    
    // Armazena a força e a direção do pulo
    Vector3 jump;

    // Referência à câmera para ajustar a direção do movimento
    public Transform cameraTransform; 

    // Velocidade padrão do movimento
    float velocidade = 5f;
    
    // Força aplicada ao pulo
    float jumpForce = 5f;
    
    // Valor da gravidade
    float gravity = -9.81f;
    
    // Estado que indica se o personagem está pulando
    bool isJumping = false;

    // Método chamado ao iniciar o jogo
    void Start()
    {
        // Obtém os componentes CharacterController e Animator do GameObject
        character = GetComponent<CharacterController>();
        animator = GetComponent<Animator>();
        
        // Inicializa o vetor de pulo como zero
        jump = Vector3.zero;
    }

    // Método chamado a cada frame
    void Update()
    {
        // Obtém os inputs do jogador para movimento horizontal e vertical
        inputs.Set(Input.GetAxis("Horizontal"), 0, Input.GetAxis("Vertical"));

        // Calcula a direção do movimento com base na orientação da câmera
        Vector3 moveDirection = cameraTransform.right * inputs.x + cameraTransform.forward * inputs.z;
        moveDirection.y = 0f; // Mantém o movimento no plano horizontal

        // Move o personagem na direção calculada
        character.Move(moveDirection * Time.deltaTime * velocidade);

        // Atualiza o estado da animação com base no input do jogador
        if (inputs != Vector3.zero)
        {
            // Ativa a animação de andar
            animator.SetBool("Andando", true);
            animator.SetBool("Parado", false);

            // Gira o personagem na direção do movimento
            transform.forward = moveDirection;
        }
        else
        {
            // Ativa a animação de parar
            animator.SetBool("Parado", true);
            animator.SetBool("Andando", false);
        }

        // Ajusta a velocidade e a animação se o jogador estiver correndo
        if (inputs != Vector3.zero && Input.GetKey(KeyCode.LeftShift))
        {
            velocidade = 9f; // Aumenta a velocidade para correr
            animator.SetBool("Parado", false);
            animator.SetBool("Correndo", true);
        }
        else
        {
            velocidade = 5f; // Define a velocidade padrão
            animator.SetBool("Correndo", false);
        }

        // Verifica se o personagem está no chão
        if (character.isGrounded)
        {
            // Zera a velocidade de queda ao tocar o chão
            jump.y = 0f;
            isJumping = false; // Reseta o estado de pulo

            // Inicia o pulo quando a tecla Espaço é pressionada
            if (Input.GetKey(KeyCode.Space))
            {
                jump.y = jumpForce; // Define a força do pulo
                isJumping = true;
                animator.SetBool("Pulando", true);
                animator.SetBool("Correndo", false);
                animator.SetBool("Andando", false);
                animator.SetBool("Parado", false);
            }
        }
        else
        {
            // Aplica a gravidade se o personagem não está no chão
            jump.y += gravity * Time.deltaTime;
            animator.SetBool("Pulando", false);
        }

        // Move o personagem com base no pulo e na gravidade
        character.Move(jump * Time.deltaTime);

        // Atualiza o estado da animação de pulo
        if (isJumping && character.isGrounded)
        {
            animator.SetBool("Pulando", false);
        }

        // Teleporta o personagem para a posição inicial se cair fora do mapa
        if (transform.position.y < -10f)
        {
            ForaDoMapa();
        }
    }

    // Método chamado para teletransportar o personagem de volta ao ponto inicial
    void ForaDoMapa()
    {
        // Desabilita o CharacterController para evitar problemas de colisão
        character.enabled = false;
        
        // Teleporta o personagem para a posição (0, 0, 0)
        transform.position = Vector3.zero;
        
        // Reabilita o CharacterController
        character.enabled = true;
    }
}
```
## Explicação do Código

### Declarações de Variáveis

- CharacterController character: Referência ao componente CharacterController que controla o movimento do personagem.
- Animator animator: Referência ao componente Animator que controla as animações do personagem.
- Vector3 inputs: Váriavel que armazena as entradas de movimento do jogador (horizontal e vertical).
- Vector3 jump: Armazena a força e a direção do pulo.
- public Transform cameraTransform: Referência à câmera para ajustar a direção do movimento.
- float velocidade = 5f: Velocidade padrão para o movimento.
- float jumpForce = 5f: Força aplicada ao pulo.
- float gravity = -9.81f: Valor da gravidade para simular a queda.
- bool isJumping = false: Estado que indica se o personagem está pulando.

### Método `Start`

- Inicializa os componentes character e animator com os componentes do GameObject.
- Define jump como Vector3.zero.

### Método `Update`

- Obtém os inputs do jogador para movimento horizontal e vertical.
- Calcula a direção do movimento com base na orientação da câmera.
- Move o personagem na direção calculada.
- Atualiza o estado da animação com base nas ações do jogador.
- Gerencia o pulo e a aplicação de gravidade.
- Chama o método 'ForaDoMapa' que teleporta o personagem para a posição inicial se ele cair fora do mapa.

### Método `ForaDoMapa`

- Desabilita o CharacterController para evitar problemas de colisão.
- Teletransporta o personagem para a posição (0, 0, 0).
- Reabilita o CharacterController.

## Explicação das Contas

### Movimento e Velocidade

- **`moveDirection * Time.deltaTime * velocidade`**: 
  - **`moveDirection`**: Direção para onde o personagem deve se mover. Calculada com base na orientação da câmera e nas entradas do jogador.
  - **`Time.deltaTime`**: Tempo desde o último frame. Garante que o movimento seja suave e consistente, independentemente da taxa de quadros.
  - **`velocidade`**: Velocidade com que o personagem se move. Ajusta a distância percorrida por segundo.

  **Como funciona**: O movimento é ajustado pela `velocidade` e o tempo desde o último frame, garantindo uma movimentação uniforme e suave.

### Pulo e Gravidade

- **`jump.y = jumpForce`**: 
  - **`jump.y`**: Velocidade vertical do pulo.
  - **`jumpForce`**: Força aplicada ao pulo, determinando a altura do pulo.

- **`jump.y += gravity * Time.deltaTime`**:
  - **`gravity`**: Valor da gravidade que puxa o personagem para baixo.
  - **`Time.deltaTime`**: Garante que a aplicação da gravidade seja consistente ao longo do tempo.

  **Como funciona**: Quando o personagem está no chão, a velocidade de pulo é definida pela `jumpForce`. No ar, a gravidade é aplicada para simular a queda, ajustada pelo tempo decorrido desde o último frame.

## Explicação das Funções e Métodos

### `Input.GetAxis`

- **`Input.GetAxis("Horizontal")` e `Input.GetAxis("Vertical")`**:
  - Retornam valores entre -1 e 1 baseados na entrada horizontal e vertical do jogador (teclas de seta ou joystick).

  **Como funciona**: Obtém as entradas do jogador para movimentar o personagem, proporcionando um controle suave e contínuo.

### `GetComponent<T>`

- **`GetComponent<CharacterController>()` e `GetComponent<Animator>()`**:
  - Obtém o componente do tipo especificado (`CharacterController` ou `Animator`) no GameObject.

  **Como funciona**: Permite que o script interaja com outros componentes no GameObject, controlando o movimento e as animações do personagem.

### `character.Move(Vector3)`

- **`character.Move(moveDirection * Time.deltaTime * velocidade)`** e **`character.Move(jump * Time.deltaTime)`**:
  - Move o personagem na direção especificada pelo vetor `Vector3`.

  **Como funciona**: Aplica o movimento ao personagem com base nas entradas do jogador e na física do jogo, como gravidade e pulo.

### `animator.SetBool`

- **`animator.SetBool("Andando", true)`**:
  - Define um parâmetro booleano no `Animator`, controlando as animações.

  **Como funciona**: Ajusta o estado da animação do personagem de acordo com as ações do jogador (andar, correr, pular).

### `Input.GetKey`

- **`Input.GetKey(KeyCode.Space)`**:
  - Retorna `true` se a tecla especificada (neste caso, a tecla de espaço) estiver pressionada.

  **Como funciona**: Verifica se o jogador pressionou a tecla para executar uma ação, como pular.

### `character.isGrounded`

- **`character.isGrounded`**:
  - Retorna `true` se o personagem estiver em contato com o chão.

  **Como funciona**: Verifica se o personagem está no chão, necessário para determinar se o pulo pode ser iniciado ou se a gravidade deve ser aplicada.

### `ForaDoMapa`

- **Método para teletransportar o personagem**:
  - Desativa o `CharacterController`, teletransporta o personagem para a posição `(0, 0, 0)`, e reativa o `CharacterController`.

  **Como funciona**: Teletransporta o personagem de volta ao ponto inicial se ele cair fora do mapa, evitando que o personagem se perca ou fique preso fora do cenário.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  

  # Script de Câmera

Este script controla a câmera para seguir o jogador. Ele ajusta a posição e a rotação da câmera com base na posição do jogador e na entrada do mouse.

## Código

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CameraFollow : MonoBehaviour
{
    // Referência ao transform do jogador
    public Transform player;

    // Distância da câmera ao jogador
    public float distance = 10.0f;  // Define a distância da câmera ao jogador
    public float height = 5.0f;     // Define a altura da câmera em relação ao jogador

    // Sensibilidade da rotação da câmera com o mouse
    public float mouseSensitivity = 100.0f;  // Controla a sensibilidade da rotação da câmera com o mouse

    // Limite de rotação vertical
    public float minYAngle = -20f;  // Limita a rotação vertical mínima
    public float maxYAngle = 60f;   // Limita a rotação vertical máxima

    private float currentX = 0f;  // Armazena a rotação atual no eixo X
    private float currentY = 0f;  // Armazena a rotação atual no eixo Y

    void Start()
    {
        // Inicializa a posição do mouse (opcional)
        Cursor.lockState = CursorLockMode.Locked;  // Tranca o cursor no centro da tela
    }

    void Update()
    {
        // Atualiza os valores de rotação com base no movimento do mouse
        currentX += Input.GetAxis("Mouse X") * mouseSensitivity * Time.deltaTime;
        currentY -= Input.GetAxis("Mouse Y") * mouseSensitivity * Time.deltaTime;

        // Limita a rotação vertical para não ultrapassar os limites definidos
        currentY = Mathf.Clamp(currentY, minYAngle, maxYAngle);
    }

    void LateUpdate()
    {
        // Cria uma posição de offset com base na rotação calculada pelo mouse
        Vector3 direction = new Vector3(0, height, -distance);  // Define a posição da câmera com base na altura e distância
        Quaternion rotation = Quaternion.Euler(currentY, currentX, 0);  // Cria uma rotação baseada nas entradas do mouse

        // Aplica a posição e rotação ao transform da câmera
        transform.position = player.position + rotation * direction;  // Calcula a posição final da câmera
        transform.LookAt(player.position);  // Faz a câmera olhar para o jogador
    }
}
```
## Explicação do Código

### Declarações de Variáveis

- **`public Transform player`**: Referência ao transform do jogador. Determina a posição do jogador para ajustar a posição da câmera.
- **`public float distance = 10.0f`**: Distância da câmera em relação ao jogador. Define o quão longe a câmera fica do jogador.
- **`public float height = 5.0f`**: Altura da câmera em relação ao jogador. Ajusta a altura da câmera acima do jogador.
- **`public float mouseSensitivity = 100.0f`**: Sensibilidade da rotação da câmera com o mouse. Controla a rapidez com que a câmera reage ao movimento do mouse.
- **`public float minYAngle = -20f`**: Limite mínimo para a rotação vertical da câmera. Impede que a câmera gire muito para cima.
- **`public float maxYAngle = 60f`**: Limite máximo para a rotação vertical da câmera. Impede que a câmera gire muito para baixo.

### Método `Start`

- **`Cursor.lockState = CursorLockMode.Locked`**: Inicializa a posição do cursor do mouse para que ele fique preso no centro da tela durante o jogo.

### Método `Update`

- **`currentX += Input.GetAxis("Mouse X") * mouseSensitivity * Time.deltaTime`**: Atualiza o valor da rotação horizontal da câmera com base no movimento do mouse.
- **`currentY -= Input.GetAxis("Mouse Y") * mouseSensitivity * Time.deltaTime`**: Atualiza o valor da rotação vertical da câmera com base no movimento do mouse.
- **`currentY = Mathf.Clamp(currentY, minYAngle, maxYAngle)`**: Limita a rotação vertical da câmera para que não ultrapasse os ângulos definidos por `minYAngle` e `maxYAngle`.

### Método `LateUpdate`

- **`Vector3 direction = new Vector3(0, height, -distance)`**: Cria uma direção para a posição da câmera com base na altura e distância do jogador.
- **`Quaternion rotation = Quaternion.Euler(currentY, currentX, 0)`**: Cria uma rotação para a câmera com base nos valores calculados de `currentY` e `currentX`.
- **`transform.position = player.position + rotation * direction`**: Ajusta a posição da câmera para seguir o jogador, aplicando a rotação calculada.
- **`transform.LookAt(player.position)`**: Faz com que a câmera olhe para a posição do jogador, garantindo que o jogador esteja sempre no centro da tela.

## Explicação das Contas

### Roteamento da Câmera

- **`currentX += Input.GetAxis("Mouse X") * mouseSensitivity * Time.deltaTime` e `currentY -= Input.GetAxis("Mouse Y") * mouseSensitivity * Time.deltaTime`**:
  - **`Input.GetAxis("Mouse X")` e `Input.GetAxis("Mouse Y")`**: Obtêm os valores do movimento do mouse, que variam entre -1 e 1.
  - **`mouseSensitivity`**: Multiplica a entrada do mouse para ajustar a rapidez da rotação.
  - **`Time.deltaTime`**: Garante que a rotação seja ajustada suavemente, independentemente da taxa de quadros.
  - **Como funciona**: O valor de rotação da câmera é ajustado com base no movimento do mouse e na sensibilidade configurada, garantindo uma resposta suave e proporcional ao movimento do jogador.

### Limitação da Rotação Vertical

- **`currentY = Mathf.Clamp(currentY, minYAngle, maxYAngle)`**:
  - **`Mathf.Clamp`**: Limita o valor de `currentY` para ficar dentro dos limites definidos por `minYAngle` e `maxYAngle`.
  - **Como funciona**: Impede que a rotação vertical da câmera ultrapasse os limites definidos, evitando ângulos de visão desconfortáveis ou impraticáveis.

### Posicionamento e Rotação da Câmera

- **`transform.position = player.position + rotation * direction`**:
  - **`rotation * direction`**: Aplica a rotação calculada ao vetor de direção para determinar a posição final da câmera.
  - **Como funciona**: Posiciona a câmera atrás e acima do jogador, ajustando a altura e a distância com base na rotação atual para fornecer uma visão adequada.

## Explicação das Funções e Métodos

### `Input.GetAxis`

- **`Input.GetAxis("Mouse X")` e `Input.GetAxis("Mouse Y")`**:
  - **`Input.GetAxis("Mouse X")`**: Obtém a entrada do movimento horizontal do mouse. Retorna um valor entre -1 e 1 que representa a direção e a magnitude do movimento horizontal.
  - **`Input.GetAxis("Mouse Y")`**: Obtém a entrada do movimento vertical do mouse. Retorna um valor entre -1 e 1 que representa a direção e a magnitude do movimento vertical.

  **Como funciona**: Esses métodos fornecem os dados de entrada do mouse, que são usados para calcular a rotação da câmera. A rotação da câmera é ajustada com base nesses valores, permitindo que a câmera siga o movimento do mouse.

### `Cursor.lockState`

- **`Cursor.lockState = CursorLockMode.Locked`**:
  - **`CursorLockMode.Locked`**: Define o estado do cursor para que ele fique preso no centro da tela e não se mova fora da janela do jogo.

  **Como funciona**: Ao bloquear o cursor, o script evita que o cursor se mova fora da área de visualização da câmera. Isso é especialmente útil para jogos em primeira pessoa ou para controle de câmera com o mouse.

### `Mathf.Clamp`

- **`Mathf.Clamp(currentY, minYAngle, maxYAngle)`**:
  - **`Mathf.Clamp`**: Garante que o valor de `currentY` permaneça dentro do intervalo definido pelos parâmetros `minYAngle` e `maxYAngle`.

  **Como funciona**: Este método impede que o valor de rotação vertical da câmera ultrapasse os limites definidos, evitando que a câmera se incline excessivamente para cima ou para baixo.

### `Quaternion.Euler`

- **`Quaternion.Euler(currentY, currentX, 0)`**:
  - **`Quaternion.Euler`**: Cria uma rotação em torno dos eixos X, Y e Z com base nos valores fornecidos. Neste caso, `currentY` e `currentX` determinam a rotação vertical e horizontal, respectivamente.

  **Como funciona**: Este método converte os ângulos de rotação em um quaternion, que é uma representação matemática da rotação. Isso permite que a câmera seja orientada na direção desejada com base nas entradas do mouse.

### `transform.position`

- **`transform.position = player.position + rotation * direction`**:
  - **`rotation * direction`**: Aplica a rotação calculada ao vetor de direção para determinar a posição final da câmera.

  **Como funciona**: Ajusta a posição da câmera com base na posição do jogador e na rotação calculada. A câmera é posicionada atrás e acima do jogador, criando uma visão ajustada e controlada com base na rotação atual.

### `transform.LookAt`

- **`transform.LookAt(player.position)`**:
  - **`transform.LookAt`**: Faz com que a câmera olhe para um ponto específico no espaço, neste caso, a posição do jogador.

  **Como funciona**: Garante que a câmera esteja sempre voltada para o jogador, mantendo-o no centro da tela e proporcionando uma perspectiva consistente durante o jogo.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------